; colorforth, 2001 jul 22, chuck moore, public domain
;
; Commented version created by Mark Tillotson from Karig's web pages
;
; Register usage:
; 0 EAX: stack (1st number on Data stack): TOS
; 1 ECX: string counter, scratch
; 2 EDX: address register A, I/O port, scratch
; 3 EBX: unused
; 4 ESP: byte pointer to top of Return stack
; 5 EBP: unused
; 6 ESI: byte pointer to 2nd number on Data stack: NOS
; 7 EDI: dword pointer to next word to be interpreted
;

.model tiny
.486p
only segment use32
assume ds:only

next macro adr
; [Refs: read, write, dev, ati0, switch, b16, b32, emit, emit2, box,
;       four1, hdot, dot, destack, insert0, insert1, enstack]
	dec	ecx
	jnz	adr
endm

dup_ macro
; [Refs: onoff, flop, readyf, white, dev, ati0, switch, warm, pause, show,
;       execute, adup, var1, short_, num, here, qlit, debug, nc_, xy_, fov_,
;       sps, last_, cyan, magenta, silver, blue, red, green, right, down,
;       blank, octant, four1, stack, keyboard, key, full, word_, word1,
;       edig1, odig, dot10, unpack, qring, ring, ww, cap, caps, type_,
;       type1, gnw1, nw1, refresh, actv, e, destack, format2, enstack]
	lea	esi, [esi-4]
	mov	[esi], eax
endm

drop macro
; [Refs: onoff, readf1, seekf, cmdf, readyf, color, dev, ati0, fifof, switch,
;       bl_, emit2, line, no, unpause, act, ex1, ex2, cshort, qcompile,
;       call_, comma, then, jump, load, erase, copy, echo_, right, lms, rms,
;       at, pat, nul0, lj, x, word0, xn, number0, number2, endn, alphn,
;       star0, hdotn, hdot, dot, d_2, qring, type0, type2, actn, e0, edit, e,
;       eout, insert0, insert1, format, ens, drop]
	lodsd
endm

; hp equ 800
; vp equ 600
; vesa equ 114h

hp equ 1024
; [Refs: start0, frame, switch, clip, b32, emit, emit2, box, hc, blank,
;       keyboard]

vp equ 768
; [Refs: start0, frame, switch, box, vc, fov, blank, keyboard]

vesa equ 117h
; [Refs: start0]

buffer equ 604*256
; [Refs: trash, destack]

include boot.asm ; boot boot0 hard

; 100000 dictionary
;  a0000 top of return stack
;  9f800 top of data stack
;  9d800 free
;  97000 floppy buffer
;   4800 source

icons equ 12*256*4 ; 3000
; [Refs: emit, emit2]

;   7c00 bios boot sector
;      0 forth

warm:
; [Refs: forth2]
	dup_

start1:
; [Refs: start2]
	call	ati0                      ; Set up video-card memory.
;	mov	screen, offset nul
;	xor	eax, eax
	call	show0                     ; Run "god" task for first time.
	mov	forths, (forth1-forth0)/4 ; Remove additions to FORTH
	mov	macros, (macro1-macro0)/4 ;   and MACRO wordlists.
	mov	eax, 18                   ; Load and run block 18.
	call	load
	jmp	accept

; ColorForth runs two tasks:
; the "god" task, which updates the Graphic Output Display
; and the "main" task, which waits for a keystroke.
; Each task has two stacks:
;   A 750-cell return stack and a 1500-cell data stack.
; Each stack grows downward in memory from its starting address
; each new item pushed "onto" the stack is stored in a cell four bytes lower
; in memory than the item pushed before.

gods equ 28000h*4 ; 0a0000h          ; 0xA0000: top of return stack for "god"
godd equ gods-750*4                  ; 0x9F448: top of data stack for "god"
mains equ godd-1500*4                ; 0x9DCD8: top of return stack for "main"
maind equ mains-750*4                ; 0x9D120: top of data stack for "main"

;.............................................................................
; Refs:
; -- gods: protected, godd, god, abort1
; -- godd: a20, cold, mains, c_, stack
; -- mains: maind, (main,) act
; -- maind: act
;
;
; SWITCHING TASKS
; The current task yields to the other task by calling pause, which preserves
; the state of the current task and jumps into round, which calls unpause to
; reload the state of the other task and to return to that task.
; For each task, there are a number of things that must be preserved:
; The top-of-stack register (TOS) - which in ColorForth is EAX.
; The next-on-stack register (NOS) - which in ColorForth is ESI.
; The return-stack pointer - which in ColorForth is ESP.
; A pointer to where the return-stack pointer is stored, which is me.
; NOTE: Unpause takes its argument via the pointer on the return stack
; that is, its data is expected to be stored inline immediately after the call,
; as it is in round. (Also note that unpause does not return to its caller.)

align 4
me	dd	offset god
screen	dd	0 ; logo

;.............................................................................
; Refs:
; -- me: pause (R), unpause (W)
; -- screen: (start1,) show
;
;
; ROUND
; Note the structure of round: For each of the two tasks, there is a call to unpause,
; followed by a variable. Clearly the system cannot simply return to the variable's
; address, and indeed it doesn't: Unpause takes the address on the return stack as an
; argument; it is the address of a variable from which information (in this case the
; return-stack pointer of the incoming task) is to be taken. Unpause also adds four
; (the size of the variable) to the return address, so that it returns to the instruction
; immediately following the variable.

round:	call	unpause            ; Pass god on return stack to unpause.
god	dd	0 ; gods-2*4
	call	unpause            ; Pass main on return stack to unpause.
main	dd	0 ; mains-2*4
	jmp	round

;.............................................................................
; Refs:
; -- round: main
; -- god: me, debug, stack
; -- main: act, debug
;
; PAUSE
; ColorForth offers cooperative multitasking, which means that the system does not interrupt
; one task to run another. The current task must stop itself and release control to the system
; so that the other task has a chance to run.
; Pause stops the current task and saves its state. It ends up jumping to a call to unpause,
; which reloads the state of the other task and causes the other task to run.
; Pause takes no arguments.

pause:
	dup_	                   ; Push TOS onto data stack..
	push	esi        ; [RST] ; Push NOS (data-stack pointer) onto return
		                   ;   stack (which already has the task's
		                   ;   return address).
	mov	eax, me            ; Get pointer (to either god or main --
		                   ;   me always points to one of the two).
	mov	[eax], esp         ; Save return-stack pointer (in god or
		                   ;   main).
	add	eax, 4             ; Get address AFTER god or main.
	jmp	eax                ; Jump there (into round, which immediately
		                   ;   calls unpause below).

;.............................................................................
; Refs -- pause: switch, forth2, key
;
; UNPAUSE
; Pause stops the current task and jumps into round, which then calls unpause, which causes
; the other task to run.

unpause:
	pop	eax        ; [RST] Return address is always god or main,
		                   ;   where return-stack pointer for OTHER
		                   ;   task is stored.
	mov	esp, [eax] ; [RST] Load other task's return-stack pointer
		                   ;   (this switches return stacks).
	mov	me, eax            ; EAX = pointer to other task's return-
		                   ;   stack pointer; save it to main or god.
	pop	esi        ; [RST] Restore other task's NOS from the return
		                   ;   stack.
	drop	                   ; Restore other task's TOS from the data
		                   ;   stack.
	ret	                   ; Return to other task, which is now the
		                   ;   current task.

;.............................................................................
; Refs -- unpause: round
;
; Starting tasks
; The words act and show tell the system what code to run when a specific task is active.
; Popping the return stack
; Certain routines in ColorForth take not only data (via the data stack) but also code
; (via the return stack). The item left on the return stack after a CALL is the address
; of the code immediately following the CALL. Therefore, a routine can get a code address
; simply by requiring that the code immediately follow the CALL.
; ColorForth has two routines for setting up each of two possible tasks: act and show.
; Each of these pops the return address and saves it somewhere.
; Nothing is pushed back onto the return stack, so each of these will return, not to its
; caller, but to its caller's caller - the code following the CALL to the routine is code
; to be run later. Act saves the code address so the code can be run as the MAIN task
; show has the code executed as the GOD (graphic output display) task.
; ACT
; Act changes the code that is run as the background or MAIN task (see this message).
; Act removes an item from each stack. The top-of-stack item (TOS) is stored as the first
; item in the MAIN task's data stack; the top item on the current return stack
; (the address of the code following the call to act) is stored as the first return address
; in the MAIN task's return stack. (It should be the GOD task that is running when act is called.)

act:
	mov	edx, maind-4       ; Get pointer to bottommost slot in "main"
	mov	[edx], eax         ;   data stack; store TOS in that slot.
	mov	eax, mains-4       ; Get pointer to bottommost slot in "main"
	pop	[eax]      ; [RST] ;   return stack; store return address.
	sub	eax, 4             ; Get pointer to next slot up in "main"
	mov	[eax], edx         ;   return stack; store pointer to TOS.
	mov	main, eax          ; Store pointer inside round.
	drop
	ret	                   ; Return to caller's caller.

;.............................................................................
; Refs -- act: show, forth2
;
; SHOW0
; This sets up both tasks - show sets up show0's code (the RET instruction) as the GOD task
; and show's own code as the MAIN task.
; Note that when show0 is run at startup, the current task is the GOD task.

show0:	call	show               ; Pass to show the pointer to "ret" on
	ret	                   ;   the return stack.

;.............................................................................
; Refs -- show0: start1

; SHOW
; Show changes the code that is run as the foreground or GOD (graphic output display) task.
; Note, however, that whenever show sets up the GOD task to run the caller's code, it also
; resets the MAIN task to run its own code.
; (Note "call [screen]" - if show is called from show0, this just returns to show
; - if show is called from refresh, this runs almost all of refresh)

show:
	pop	screen     ; [RST] ;
	dup_
	xor	eax, eax
	call	act

; The call to act is effectively the end of the show routine, because act forces a return
; to show's caller.

	; ret

; The code that follows is the code to be run as the MAIN task. Note two things:
; First, this code is a loop. Because the address of this code is stored as the bottommost
; return address in the MAIN return stack, it has to be a loop; once the system has returned
; to this code, the return stack is empty. A RET instruction here would cause a system crash.
; Second, the code passed to either act or show must lead eventually to a call to pause so
; that the other task can be run. In this case, the call to switch causes pause to execute.

@@:	call	graphic
	call	[screen]
	call	switch             ; (Switches tasks via jump to pause)
	inc	eax
	jmp	@b

;.............................................................................
; Refs -- show: show0, forth2, refresh

; Hint in difference between pause and unpause: Pause saves ESP where "me" points.
; Unpause does NOT retrieve ESP from where "me" points
; instead it loads ESP from the address on the return stack.
; (Pause does not alter "me"; unpause does.) Note also that, at startup, "me" already
; contains a pointer to "god".
; So what happens when a ColorForth block calls show?

; C
; Change NOS to point to highest cell in return stack for "god" ("godd" marks the address
; one cell HIGHER than the highest-addressed cell in the data stack, so "godd+4" is not in
; the data stack)

c_: ;"c"
; [Refs: forth2]
	mov	esi, godd+4
	ret

; ADDING TEMPORARY DEFINITIONS

mark:
; Set beginning of definitions that will be removed by empty.
; [Refs: forth2]
	mov	ecx, macros    ; Save # words in MACRO wordlist.
	mov	mk, ecx
	mov	ecx, forths    ; Save # words in FORTH wordlist.
	mov	mk+4, ecx
	mov	ecx, h         ; Save end-of-dictionary pointer.
	mov	mk+2*4, ecx
	ret

empty: ;"empt"
; [Refs: forth2]
	mov	ecx, mk+2*4    ; Restore end-of-dictionary pointer.
	mov	h, ecx
	mov	ecx, mk+4      ; Restore # words in FORTH wordlist.
	mov	forths, ecx
	mov	ecx, mk        ; Restore # words in MACRO wordlist.
	mov	macros, ecx
	mov	class, 0       ; (?)
	ret

; FINDING WORDS
; These routines return with ECX = offset into wordlist to word if zero flag set(?)
; [note how instructions affect zero flag]

mfind:
; Look up word in MACRO wordlist.
; [Refs: qcompile, compile]
	mov	ecx, macros
	push	edi
	lea	edi, [macro0-4+ecx*4]
	jmp	@f

find:
; Look up word in FORTH wordlist.
; [Refs: ex1, ex2, qcompile]
	mov	ecx, forths
	push	edi
	lea	edi, [forth0-4+ecx*4]
@@:	std
	repne	scasd
	cld
	pop	edi
	ret

; EXECUTING WORDS

ex1:
; [Refs: ex1, aword, eout]
	dec	words ; from keyboard
	jz	@f
	drop
	jmp	ex1
@@:	call	find
	jnz	abort1
	drop
	jmp	[forth2+ecx*4]

execute:
; Used by inter to handle yellow (color=1, execute) words.
; [Refs: spaces]
	mov	lit, offset alit
	dup_
	mov	eax, [-4+edi*4]            ; Grab the next pre-parsed word.

ex2:
; [Refs: none]
	and	eax, -20o                  ; Mask out color bits (bits 0..3).
	call	find                       ; Look up word in FORTH wordlist.
	jnz	abort                      ; If not found, abort.
	drop
	jmp	[forth2+ecx*4]             ; Run the word's definition.

; CANCELING EXECUTION

abort:
; [Refs: ex2, qcompile (qring, insert1) ]
	mov	curs, edi
	shr	edi, 10-2
	mov	blk, edi

abort1:
; [Refs: ex1, copy]
	mov	esp, gods ; [RST]
	mov	spaces+3*4, offset forthd
	mov	spaces+4*4, offset qcompile
	mov	spaces+5*4, offset cnum
	mov	spaces+6*4, offset cshort
	mov	eax, 57o ; ?       ; (57o = value for '?' in encoding scheme)
	call	echo_
	jmp	accept

; ADDING WORDS TO THE DICTIONARY
; ColorForth offers two routines to add a word to the dictionary - one routine for each wordlist.
; The address of the routine to use is stored in adefine, the word-definition vector.
; Macro_ uses sdefine to store the address of macrod into this vector, while forth uses sdefine
; to store the address of forthd.
; Sdefine takes the address of a word-definition routine, but it takes the address off the return stack.
; This allows the caller to pass the address simply by calling sdefine
; (as long as the address is intended to be the address of the instruction following the call).
; This leads to simpler code than would be required to pass an address on the data stack.
; Of course this means that (1) the code after the call is not run when sdefine returns, and
; (2) sdefine returns not to its caller but to its caller's caller.

sdefine:
; Sets word-definition vector. Called when current wordlist changes.
; [Refs: macro_, forth]
	pop	adefine ; [RST]
	ret

macro_: ;"macro"
; Points word-definition vector at macrod.
; [Refs: adefine, forth2]
	call	sdefine
	; Does NOT fall through to macrod.

macrod:
; Defines new word and adds it to the MACRO wordlist.
; Used by inter to handle red (color=3, define) words
;  (if the current wordlist is MACRO).
; [Refs: variable (adefine)]
	mov	ecx, macros
	inc	macros
	lea	ecx, [macro0+ecx*4]
	jmp	@f

forth:
; Points word-definition vector at forthd.
; [Refs: forth2]
	call	sdefine
	; Does NOT fall through to forthd.

forthd:
; Defines new word and adds it to the FORTH wordlist.
; Used by inter to handle red (color=3, define) words
;  (if the current wordlist is FORTH).
; [Refs: abort1, variable]
	mov	ecx, forths              ; Increment number of words in the
	inc	forths                   ;   FORTH wordlist.
	lea	ecx, [forth0+ecx*4]      ; Make offset into FORTH word array.
@@:	mov	edx, [-4+edi*4]          ; Grab pre-parsed word.
	and	edx, -20o                ; Clear color bits (bits 0..3).
	mov	[ecx], edx               ; Store result at end of word array.
	mov	edx, h                   ; Store end-of-dictionary pointer
	mov	[forth2-forth0+ecx], edx ;   into wordlist's address array.
	lea	edx, [forth2-forth0+ecx] ; Get address of address-array cell.
	shr	edx, 2                   ; Convert it into DWORD address.
	mov	last, edx                ; Store it (to allow optimization).
	mov	list, esp                ; -- ???? --
	mov	lit, offset adup         ; -- ???? --
	test	class, -1                ; Call custom routine only if
	jz	@f                       ;   vector is non-zero.
	jmp	[class]
@@:	ret	                         ; Otherwise simply return.
;;;;;;;;;;;;;;;;;;NOTE--TEMP
			; ECX = byte pointer to word within word array.
			; EDX = DWORD pointer to addr within addr array.
;;;;;;;;;;;;;;;;;;NOTE--TEMP

; ColorForth's compiler works by adding bytes of machine code to the end of a buffer called
; the dictionary. (This buffer starts at address 0x100000 - the one-megabyte mark - and
; extends upward in memory.) ColorForth maintains a pointer to the end of this buffer in
; the variable h.
;
; Words in the MACRO wordlist are executed at compile-time in order to add bytes of machine
; code to the definition of the word currently being defined. These words also provide
; opportunities for other macro words to optimize the machine code generated. Sometimes a
; word will leave in list the address of the machine code that the word adds to the
; definition. Another word will check list to see if a specific instruction is in the
; definition, and if so, the word may take the instruction out or substitute another one.
;
; DROP
;
; The word drop removes the top item from the data stack. Specifically, it moves the second
; item on the stack into the TOS register, overwriting the original top item, and adjusts
; the NOS register to point to what was the third item on the stack. The result is one cell
; fewer on the stack.
;
; ColorForth implements drop as the one-byte LODSD instruction (machine-code value: 0xAD).
; Therefore the routine to compile a drop simply adds the machine-code value for LODSD at
; the end of the dictionary and increments the end-of-dictionary pointer by one byte.
; However, this version also stores the old end-of-dictionary pointer (the location of the
; LODSD instruction being added) into list, so that if another routine (such as qdup) wants
; to optimize away the LODSD, it can do so.
;
cdrop: ;"drop"
; [Refs: qlit, macro2]
	mov	edx, h
	mov	list, edx
	mov	byte ptr [edx], 0adh ; lodsd
	inc	h
	ret

; DUP
;
; The word dup pushes a copy of TOS onto the data stack. Specifically, it adjusts the NOS
; register to make room for an extra cell on the stack and copies TOS into this extra cell.
; The result is one cell more on the stack.
;
; The ColorForth kernel defines two routines for compiling dup: qdup and cdup.
;
; Optimized DUP (qdup)
;
; The word ?dup is often used at the beginning of a macro word to compile a dup only if the
; definition of the word being defined does not already end with a drop (i.e., a LODSD
; instruction). If the drop is there, it is removed, and dup is not compiled.

qdup: ;"?dup"
; [Refs: literal, macro2]
	mov	edx, h               ; See if the last optimizable instruc-
	dec	edx                  ;   tion was one byte back from the end
	cmp	list, edx            ;   of the dictionary.
	jnz	cdup                 ; If not, go compile a DUP.
	cmp	byte ptr [edx], 0adh ; If so, was the instruction DROP?
	jnz	cdup                 ; If not, go compile a DUP.
	mov	h, edx               ; If so, remove the DROP and continue compilation
	ret

; Non-optimized DUP (cdup)
;
; If the programmer knows that the preceding instruction was not a drop, he can just compile a
; dup directly.
;
; Note that the dword and byte being added to the dictionary correspond to the five bytes (in
; hex) 8D 76 FC 89 06. The first three bytes are the machine code for the instruction lea esi,
; [esi-4]; the last two correspond to mov [esi], eax. (ESI is NOS, the pointer to the next
; [second] item on the stack. The stack grows downward, and the size of each item on the stack
; is four bytes, so lea esi, [esi-4] makes room on the stack for another item. EAX is TOS, the
; register containing the top item on the stack, so mov [esi], eax copies TOS into the new
; space.)

cdup: ;"dup"
; [Refs: qdup, macro2]
	mov	edx, h
	mov	dword ptr [edx], 89fc768dh
	mov	byte ptr [4+edx], 06
	add	h, 5
	ret

; THE INTERPRETER

; This isn't the entire interpreter; the complete list of routines called by inter is at spaces/adefine.

adup:
; [Refs: forthd, alit, lit]
	dup_
	ret

var1:
; [Refs: variable]
	dup_
	mov	eax, [4+forth0+ecx*4]
	ret

; VARIABLE
;
; The interpreter calls variable when it encounters a magenta word (a variable to be defined).
;
; Recall that ColorForth defines two wordlists - FORTH and MACRO. If a pre-parsed word is
; green, then what the interpreter does with the word depends on the wordlist in which the
; word is found. If the word is in the MACRO wordlist, then the word's definition (machine
; code) is executed immediately. If the word is in the FORTH wordlist, then a CALL to the
; word's definition is compiled at the end of the dictionary (machine-code buffer).
;
; Recall also that ColorForth defines each wordlist as a pair of arrays - a word array and an
; address array. A pre-parsed word is sought in the word array. If a match is found, then the
; address of the word's definition will be found at the same offset in the address array.
;
; Defining a new word usually creates one new entry - one new word and one new address - in
; one of the two wordlists. Defining a variable is more expensive; a variable definition uses
; four wordlist entries - two entries in each wordlist. The data added to the wordlists are as
; follows:
;
; FORTH wordlist
; Word (name) Address
; word var1
; [4+ecx]
;
; MACRO wordlist
; Word (name) Address
; word var2
; [4+ecx]
;
;
; When the interpreter finds a magenta word, it calls variable to handle the word. Variable
; calls forthd to add the word to the FORTH wordlist, set the ECX register to the address of
; the word-array cell that contains the new word, and set the word's address field to the
; address of the end of the dictionary as usual. Variable stores into this address field the
; address of var1, which does nothing except push [4+forth0+ecx*4] onto the stack. Variable
; then creates a dummy entry in the FORTH wordlist, into which is stored the address of the
; pre-parsed word after the magenta word being handled. This address goes into the word array;
; the corresponding cell in the address array is left unused. (This word-array cell for the
; dummy entry is the address to which "[4+forth0+ecx*4]" refers.)

variable:
; Used by inter to handle magenta (color=12, variable) words.
; [Refs: adefine]
	call	forthd
	mov	[forth2-forth0+ecx], offset var1
	inc	forths ; dummy entry for source address
	mov	[4+ecx], edi

; Then variable creates parallel entries in the MACRO wordlist. This operation is the same as
; above, except that variable calls macrod instead of forthd, and it stores, not the address of
; var1, but the address of the routine following variable (marked in the code with a local
; label "@@"), which I choose to call "var2".

	call	macrod
	mov	[forth2-forth0+ecx], offset @f
	inc	macros
	mov	[4+ecx], edi

;
; The wordlist entries created, variable increments the pre-parsed-word pointer, so that the
; interpreter will not interpret the value following the magenta word (which of course is the
; value of the variable).

	inc	edi
	ret

;
; So how is a variable used after it is defined?
;
; Chuck Moore states that yellow variables are preferred on the Pentium, that is, you use a
; variable by having its address pushed onto the stack at compile time. When the interpreter
; finds a yellow word, it looks up the word in the FORTH wordlist and executes the code at the
; address found in the word's entry. In this case, the address is that of var1, which grabs the
; address from the word field of the next (dummy) entry in the wordlist and pushes it onto the
; stack at compile time. This address is of course that of the variable's value, stored within
; the pre-parsed source code.
;
; What if a variable name is green? Chuck Moore states: "A green variable compiles a call to
; code executed at run time to put the address on the stack." When the interpreter finds a
; green word, it looks up the word first in the MACRO wordlist, then in the FORTH wordlist. In
; this case, the interpreter will find the variable name in the MACRO wordlist (since the name
; was added to both wordlists). The address in the MACRO wordlist is that of "var2" below
; which generates code to push the address of the variable's value onto the stack at run time.
;
; "var2"
;
; -- routine called if variable is invoked as a MACRO --

@@:	call	[lit]
	mov	eax, [4+macro0+ecx*4]
	jmp	@f

; CNUM
;
; Cnum ("compile number") takes a 32-bit number from the pre-parsed source code and
; compiles it into the machine code needed to push that number onto the stack.
;
; A 32-bit number is stored in the pre-parsed code as two 32-bit cells. Only the
; bottom five bits of the first cell are used the bottom four bits are the "color,"
; in this case color five (a "green" number to be compiled), and the other bit
; indicates whether the number should be displayed as decimal or hexadecimal. The
; second cell contains the 32-bit number.
;
; Whereas most routines called by inter (the interpreter loop) access the current pre-
; parsed word via [-4+edi*4], cnum needs to access the following pre-parsed word (the
; 32-bit number itself) via [edi*4].

cnum:
; Used by inter to handle green (color=5, 32-bit number) words.
; [Refs: abort1, adefine]
	call	[lit]
	mov	eax, [edi*4]         ; Get cell AFTER "prefix."
	inc	edi
	jmp	@f

; CSHORT
;
; Cshort ("compile short number") takes a 27-bit number from the pre-parsed source
; code and compiles it into the machine code needed to push that number onto the
; stack.
;
; A number small enough to be represented in 27 or fewer bits is stored in the pre-
; parsed source code as a single cell. The bottom four bits contain the "color," in
; this case color six (a "green" number to be compiled), the next bit indicates
; whether to display the number as decimal or hexadecimal, and the other 27 bits
; contain the number.

cshort:
; Used by inter to handle green (color=6, 27-bit number) words.
; [Refs: abort1, adefine]
	call	[lit]
	mov	eax, [-4+edi*4]
	sar	eax, 5
@@:	call	literal
	drop
	ret

alit:
; [Refs: execute, adup, short_, num]
	mov	lit, offset adup

; literal

; Literal takes the 32-bit number at the top of the stack and compiles from it the
; machine code needed to push that number onto the stack later. (In most cases it
; generates a dup followed by a MOV EAX, <32_bit_number> instruction.) Note that
; this routine does not drop the number from the stack after compiling it.

literal:
; [Refs: cshort]
	call	qdup                 ; Compile code to preserve top of stack.
	mov	edx, list            ; Preserve previous instruction address
	mov	list+4, edx          ;   saved for optimization.
	mov	edx, h               ; Save address of the "MOV EAX"
	mov	list, edx            ;   instruction about to be compiled.
	mov	byte ptr [edx], 0b8h ; Compile "MOV EAX, <literal>" --
	mov	[1+edx], eax         ;   using the literal on the stack.
	add	h, 5                 ; Adjust end-of-dictionary pointer.
	ret

; qcompile

; Qcompile retrieves the next pre-parsed word from the source code and looks it up,
; first in the MACRO wordlist, then in the FORTH wordlist. If the word is found in
; the MACRO wordlist, the word's definition is executed. If the word is found in the
; FORTH wordlist, a CALL to the word's definition is compiled into the dictionary.
; If the word is found in neither, the interpreter aborts.

qcompile:
;Used by inter to handle green (color=4, compile) words.
; [Refs: abort1, adefine]
	call	[lit]                ; For info, search for "lit	dd offset adup"
	mov	eax, [-4+edi*4]      ; Get next pre-parsed word.
	and	eax, -20o            ; Mask out color bits (bits 0..3).
	call	mfind                ; Look it up in MACRO wordlist.
	jnz	@f
	drop	                     ; If found in MACRO wordlist,
	jmp	[macro2+ecx*4]       ;   execute its definition immediately.
@@:	call	find                 ; Otherwise, find it in FORTH wordlist.
	mov	eax, [forth2+ecx*4]
@@:	jnz	abort

; call_

; Call_ takes the routine address at the top of the stack and compiles from it the
; machine code needed to call that routine.

call_:
; [Refs: none]
	mov	edx, h
	mov	list, edx
	mov	byte ptr [edx], 0e8h ; Store CALL opcode into dictionary.
	add	edx, 5               ; Calculate correct offset from the CALL
	sub	eax, edx             ;   instruction to the routine called.
	mov	[-4+edx], eax        ; Store offset into dictionary.
	mov	h, edx
	drop
	ret

compile:
; Used by inter to handle cyan (color=7, compile macro) words.
; [Refs: adefine]
	call	[lit]
	mov	eax, [-4+edi*4]
	and	eax, -20o
	call	mfind
	mov	eax, [macro2+ecx*4]
	jmp	@b

short_:
; Used by inter to handle yellow (color=8, 27-bit number) words.
; [Refs: adefine]
	mov	lit, offset alit
	dup_
	mov	eax, [-4+edi*4]
	sar	eax, 5
	ret

num:
; Used by inter to handle yellow (color=2, 32-bit number) words.
; [Refs: spaces]
	mov	lit, offset alit
	dup_
	mov	eax, [edi*4]
	inc	edi
	ret

; Writing machine code into the dictionary
;
; These words allow the ColorForth programmer to create MACRO words that write
; machine code into the dictionary, from one to four bytes at a time.

comma: ;","
; Moves a cell (four bytes) of machine code to the end of the dictionary.
; [Refs: forth2]
	mov	ecx, 4
@@:	mov	edx, h
	mov	[edx], eax
	mov	eax, [esi] ; drop
	lea	edx, [edx+ecx]
	lea	esi, [esi+4]
	mov	h, edx
;	drop
	ret

comma1: ;"1,"
; Moves one byte of machine code to the end of the dictionary.
; [Refs: forth2]
	mov	ecx, 1
	jmp	@b

comma2: ;"2,"
; Moves two bytes of machine code to the end of the dictionary.
; [Refs: forth2]
	mov	ecx, 2
	jmp	@b

comma3: ;"3,"
; Moves three bytes of machine code to the end of the dictionary.
; [Refs: forth2]
	mov	ecx, 3
	jmp	@b

; Macro words

; The semicolon (;) is another optimizing word. It works like this: If the last
; optimizable instruction compiled was a CALL, change this to a JuMP; otherwise add
; a RETurn instruction to the end of the dictionary.
;
; One nice side effect of this, as Chuck Moore has observed, is that this allows
; tail recursion of words in the FORTH wordlist, like this:
;
; word ... condition if word ; then ... ;
;
; If a word calls itself, it would normally fill the return stack with copies of the
; same return address but if it jumps to the beginning of its own definition
; instead, the return stack is not overfilled.

semi: ;";"
; Compiles code to return to caller (either JMP or RET).
; [Refs: macro2]
	mov	edx, h
	sub	edx, 5
	cmp	list, edx
	jnz	@f
	cmp	byte ptr [edx], 0e8h
	jnz	@f
	inc	byte ptr [edx] ; jmp
	ret
@@:	mov	byte ptr [5+edx], 0c3h ; ret
	inc	h
	ret

then:
; [Refs: macro2]
	mov	list, esp
	mov	edx, h
	sub	edx, eax
	mov	[-1+eax], dl
	drop
	ret

begin:
; [Refs: macro2]
	mov	list, esp

here:
; Returns end-of-dictionary pointer on data stack.
; [Refs: forth2]
	dup_
	mov	eax, h
	ret

; qlit: If the last instruction in the dictionary is "MOV EAX, literal", move the
; literal onto the data stack and remove the instruction from the dictionary. If the
; instruction was preceded by a DUP, remove that also. Returns with zero flag set if
; nothing placed on stack, cleared if literal on stack.
;
; usage: ... ?lit if do-something-with-literal drop then ... ;

qlit: ;"?lit"
; [Refs: forth2]
	mov	edx, h
	lea	edx, [edx-5]
	cmp	list, edx
	jnz	@f
	cmp	byte ptr [edx], 0b8h
	jnz	@f
	dup_
	mov	eax, list+4
	mov	list, eax
	mov	eax, [1+edx]
	cmp	dword ptr [edx-5], 89fc768dh ; dup
	jz	q1
	mov	h, edx
	jmp	cdrop

q1:
; [Refs: qlit]
	add	h, -10 ; flag nz
	ret
@@:	xor	edx, edx ; flag z
	ret

less:
; [Refs: forth2]
	cmp	[esi], eax
	jl	@f ; flag nz        ; Bug-fix! Original was "js"
	xor	ecx, ecx ; flag z
@@:	ret

; qignore

; If the interpreter has found the last pre-parsed word (a "null" cell), qignore
; pops the return stack twice. The effect is to return to the caller of load.
; Qignore has to pop two items from the return stack: the address to return to
; load, and the value that was in EDI before load pushed it onto the return stack.
; The RET instruction returns control to the routine that called load.
;
; (MY THEORY: Popping a return address and returning to the caller's caller might
; save a code-cache flush-and-refill, because if you return to a caller, this
; potentially causes the processor to flush the code cache and refill it if the
; caller's code is, for whatever reason, not in the cache -- not likely, but
; possible -- This is especially wasteful if the caller just executes another RET
; immediately afterward, because that's potentially another flush-and-refill. This
; is a VERY small concern in this case, of course, but Chuck Moore has implied that
; you keep improving your software by handling these small concerns because the
; effects of doing so build up eventually, and you end up with smaller, faster
; code.)

qignore:
; Used by inter to handle extension (color=0) words.
; [Refs: spaces]
	test	dword ptr [-4+edi*4], -20o ; Unless word's top 28 bits are
	jnz	nul                        ;   null, return to interpreter.
	pop	edi ; [RST]                ; Otherwise, exit interpreter.
	pop	edi ; [RST]

nul:
; [Refs: start1, qignore, adefine, anumber, display, ekeys, ekbd0, eout]
	ret

; jump

; The word jump introduces a jump table within ColorForth code, like this:

; word ... number jump word0 word1 word2 ... ;

; Here, number causes some number N to be pushed onto the stack, and jump takes that
; number and jumps to wordN (the Nth word afterward).
;
; Note that the code here expects that each entry in the jump table is five bytes
; long, with the address of the word's definition in the latter four bytes which
; is what compiling a word in the FORTH wordlist generates: a CALL to an address. A
; jump table containing MACRO words, generally speaking, will not work.

jump:
; [Refs: forth2]
	pop	edx ; [RST]
	add	edx, eax
	lea	edx, [5+eax*4+edx]
	add	edx, [-4+edx]
	drop
	jmp	edx

; load
;
; Load does not load blocks from disk; the blocks are assumed to be in memory
; already. Load simply multiplies the block number by 256 (0x100) to get the block's
; address. (Thus block 18 (0x12) is at address (0x12 shl 8) or 0x1200.) The
; interpreter begins grabbing the pre-parsed words already in memory and using each
; word's color bits to determine the routine to use to handle that word.

load:
; ( b -- ) Interprets pre-parsed words in the block given.
; [Refs: start1, forth2]
	shl	eax, 10-2
	push	edi ; [RST]
	mov	edi, eax
	drop

; inter

; Note that inter is an endless loop. The only way to return from the interpreter
; (e.g., when the interpreter has no more pre-parsed words to interpret) is for a
; routine called by the interpreter (such as qignore) to pop an item from the return
; stack before returning (and thus to return to inter's caller). (Only qignore
; checks for the last word in the pre-parsed code, so there is no need for inter to
; do it.)

inter:
; [Refs: inter]
	mov	edx, [edi*4]
	inc	edi           ; (Thus all routines work on [-4+edi*4].)
	and	edx, 17o      ; Clear all bits except color bits (0..3).
	call	spaces[edx*4] ; Use result as offset to routine to run.
	jmp	inter

; 16 Interpreter Vectors:
;
; 0 extension
; 1 execute yellow
; 2 execute yellow 32bit number
; 3 define red
; 4 compile green
; 5 compile green 32bit number
; 6 compile green 27bit number
; 7 compile cyan
; 8 execute yellow 27bit number
; 9 comment white
; a Capitalized white
; b all caps white
; c variable magenta
; d null
; e null
; f null

align 4
; [Refs: abort1, inter, sps]
spaces	dd offset qignore, offset execute, offset num           ; colors 0..2

; [Refs: sdefine]
adefine	dd 5+offset macro_                                          ; color 3
		; This is altered by sdefine, which stores the
		; address of either macrod (to define a MACRO
		; word) or forthd (to define a FORTH word) here.
	dd offset qcompile, offset cnum, offset cshort, offset compile ; 4..7
	dd offset short_, offset nul, offset nul, offset nul          ; 8..11
	dd offset variable, offset nul, offset nul, offset nul       ; 12..15

; Other variables
;
; lit
;
; This code vector points to either of two routines:
;
; 1 - adup: The routines forthd/macrod and alit store the address of adup into lit.
; 2 - alit: The routines execute, short_, and num store the address of alit into lit.
; The routines that set lit to point to alit are all routines that handle yellow
; cells (words or numbers), so alit is needed only to handle immediate execution of
; words, and not for defining or compiling. Lit usually points to adup it is reset
; to adup's address not only whenever a word is being defined but also whenever alit
; is called.
;
; (But is [lit] called during handling of current word, or between words? I remember
; something about the transition between yellow and green words, or vice versa,
; causing something special with the compiler.)
;
; It is helpful here to check out what each of the interpreter subroutines does with
; the stack. Nul of course does nothing, and qignore, macrod, forthd, and variable
; all scrupulously avoid altering the stack. Execute uses the stack but then
; restores it to what it was. Num and short_ both leave something on the stack,
; while the remaining routines; qcompile, cnum, cshort, and compile, all execute
; "call [lit]" first thing, use the TOS without first executing a DUP, and then DROP
; later.
;
; Now look at what the two lit routines do. Adup duplicates the TOS and returns,
; while alit, like qignore and the word-definition routines, scrupulously avoids
; altering the stack.
;
; Now we begin to see how these routines work together. Num and short_ both leave
; something on the stack, and they both set lit to alit. The following invocation of
; any of qcompile, cnum, cshort, or compile does a call [lit], which results in alit
; being executed, which avoids altering the stack but does create a mov eax,
; <literal> instruction using the TOS (the number placed on the stack by either num
; and short_) as the literal. Once alit is called, lit is restored to adup, so that
; if qcompile or any other routine that does a call [lit] is called again, adup is
; called, which just preserves the TOS and returns, so that the caller can safely
; overwrite the TOS.
;
; Note that execute does not leave anything on the stack itself, but it is invoked
; when the interpreter finds a yellow word, whose definition is supposed to leave
; something (a single number, per Chuck Moore) on the stack. Other than that, it
; acts like num and short_, in that it sets lit to alit, so that the item left on
; the stack can be compiled into a mov eax, <item> instruction.

; lit
; [Refs: execute, forthd, variable, cnum, cshort, alit, qcompile, compile, short_, num]
lit	dd offset adup

; [Refs: mark, empty]
mk	dd 0, 0, 0

; h
;
; This is the pointer to the end of the code space the next byte to be overwritten
; when a word needs to be compiled. The code space begins at address 0x100000 (the
; one-megabyte mark), so if the code space is empty, h is set at 0x100000. As the
; compiler adds bytes of machine code to the code space, h advances.

; [Refs: mark, empty, forthd, cdrop, qdup, cdup, literal, call_, comma, semi,
;       then, here, qlit, q1]
h	dd 40000h*4

; last
;
; (forthd stores into "last" the DWORD pointer to last word defined -- the
; "colorless" pre-parsed word stored in the word array of whichever of the two
; wordlists was last updated -- presumably "last" is used for optimizing code)


; [Refs: forthd, last_]
last	dd 0

; class
;
; From what I can tell, class always contains zero. Empty stores a zero here. Forthd
; will use this as a pointer to code if it is nonzero, but it doesn't store anything
; here. I have found no other references to class anywhere in the kernel, and class
; doesn't seem to be exposed in any way via the two wordlists. I'm guessing that
; this was intended as a way to customize the interpreter by having some custom code
; executed whenever a word is defined, except that I haven't found any way to do
; that except by altering the assembly-language source and reassembling ColorForth.


; [Refs: empty, forthd]
class	dd 0

; list
;
; This is a list of up to two addresses within the dictionary. Each address is that
; of a previously compiled instruction an instruction that could later be changed
; or removed in order to optimize the machine code.


; [Refs: forthd, cdrop, qdup, literal, call_, semi, then, begin, qlit]
list	dd 0, 0

; Wordlists
;
; ColorForth comes with two wordlists: FORTH and MACRO. A word in the FORTH wordlist
; is compiled as a CALL to the address of the word's definition in the dictionary. A
; word in the FORTH wordlist is executed at compile-time (the word can be green; it
; does not have to be yellow); it is equivalent to an "immediate" word in older
; versions of Forth.
;
; Each wordlist has three parts:
;
; Part FORTH wordlist MACRO wordlist
; Word count forths macros
; Word array forth0 macro0
; Address array forth2 macro2
;
; The word count indicates how many words are defined in the wordlist. The word
; array contains words in pre-parsed format (with color bits set to zero), and the
; address array contains addresses of word definitions. If you can find a given word
; in the word array, the offset to that word will, when applied to the address
; array, yield the address of that word's definition.
;
; In addition to the words provided by the kernel, the wordlists have room for new
; words. The programmer can add up to 512 new words to the FORTH wordlist and up to
; 128 new words to the MACRO wordlist.
;
;
; Example 1: dd 170o shl 25 -- ";" -- A semicolon is 1111 000 (170o) -- seven bits
; wide, so we slide it up by (32-7) or 25 bits
;
; Example 2: dd (24o shl 5+21o) shl 22 -- "lm" -- "l" is 10100 (24o), 5 bits wide --
; "m" is 10001, also 5 bits wide -- slide everything up by (32-5-5) or 22 bits
;
; Example 3: dd ((26o shl 4+3) shl 7+141o) shl 16) -- "fov" -- "f" is 10110, "o" is
; 0011, "v" is 1100 001 -- slide everything up by (32-5-4-7) or 16 bits


; [Refs: start1, mark, empty, mfind, macrod, variable]
macros	dd 0

; [Refs: start1, mark, empty, find, forthd, variable]
forths	dd 0


; [Refs: start1, mfind, macrod, variable]
macro0	dd 170o shl 25 ; ;
	dd ((140o shl 7+146o)shl 7+142o)shl 11 ; dup
	dd (((177o shl 7+140o)shl 7+146o)shl 7+142o)shl 4 ; ?dup
	dd (((140o shl 4+1)shl 4+3)shl 7+142o)shl 10 ; drop
	dd (((2 shl 7+144o)shl 4+4)shl 4+6)shl 13 ; then
	dd ((((143o shl 4+4)shl 5+25o)shl 4+7)shl 4+6)shl 8 ; begin


; [Refs: start1]
macro1	dd 128 dup (0)


; [Refs: start1, find, forthd, var1, variable]
forth0	dd (((143o shl 4+3)shl 4+3)shl 4+2)shl 13 ; boot = c6664000 = 11000110011001100100000... = 1100011 (b) 0011 (o) 0011 (o) 0010 (t)
	dd (((27o shl 4+5)shl 4+1)shl 5+21o)shl 14 ; warm
	dd ((((142o shl 4+5)shl 7+146o)shl 5+20o)shl 4+4)shl 5 ; pause
	dd ((((21o shl 4+5)shl 5+22o)shl 4+1)shl 4+3)shl 10 ; macro
	dd ((((26o shl 4+3)shl 4+1)shl 4+2)shl 7+144o)shl 8 ; forth
	dd 22o shl 27 ; c
	dd (((20o shl 4+2)shl 4+3)shl 7+142o)shl 12 ; stop
	dd (((1 shl 4+4)shl 4+5)shl 7+140o)shl 13 ; read
	dd ((((27o shl 4+1)shl 4+7)shl 4+2)shl 4+4)shl 11 ; write
	dd (6 shl 5+22o)shl 23 ; nc
	dd (((((22o shl 4+3)shl 5+21o)shl 5+21o)shl 4+5)shl 4+6)shl 5 ; comman d
	dd (((20o shl 4+4)shl 4+4)shl 7+164o)shl 12 ; seek
	dd ((((1 shl 4+4)shl 4+5)shl 7+140o)shl 5+23o)shl 8 ; ready
	dd ((5 shl 5+22o)shl 4+2)shl 19 ; act
	dd (((20o shl 7+144o)shl 4+3) shl 5+27o)shl 11 ; show
	dd (((24o shl 4+3)shl 4+5)shl 7+140o)shl 12 ; load
	dd (((144o shl 4+4)shl 4+1)shl 4+4)shl 13 ; here
	dd (((177o shl 5+24o)shl 4+7)shl 4+2)shl 12 ; ?lit
	dd (153o shl 7+176o) shl 18 ; 3,
	dd (152o shl 7+176o) shl 18 ; 2,
	dd (151o shl 7+176o) shl 18 ; 1,
	dd 176o shl 25 ; ,
	dd (((24o shl 4+4)shl 5+20o)shl 5+20o)shl 13 ; less
	dd (((162o shl 7+146o)shl 5+21o)shl 7+142o)shl 6 ; jump
	dd (((((5 shl 5+22o)shl 5+22o)shl 4+4)shl 7+142o)shl 4+2)shl 3 ; accept
	dd ((142o shl 4+5)shl 7+140o)shl 14 ; pad
	dd ((((4 shl 4+1)shl 4+5)shl 5+20o)shl 4+4)shl 11 ; erase
	dd (((22o shl 4+3)shl 7+142o)shl 5+23o)shl 11 ; copy
	dd (((21o shl 4+5)shl 4+1)shl 7+164o)shl 12 ; mark
	dd (((4 shl 5+21o)shl 7+142o)shl 4+2)shl 12 ; empt
	dd (((4 shl 5+21o)shl 4+7)shl 4+2)shl 15 ; emit
	dd ((((140o shl 4+7)shl 5+25o)shl 4+7)shl 4+2)shl 8 ; digit
	dd ((((152o shl 4+4)shl 5+21o)shl 4+7)shl 4+2)shl 8 ; 2emit
	dd 165o shl 25 ; .
	dd (144o shl 7+165o)shl 18 ; h.
	dd ((144o shl 7+165o)shl 4+6)shl 14 ; h.n
	dd (22o shl 4+1)shl 23 ; cr
	dd ((((20o shl 7+142o)shl 4+5)shl 5+22o)shl 4+4)shl 7 ; space
	dd (((140o shl 4+3)shl 5+27o)shl 4+6)shl 12 ; down
	dd (((4 shl 7+140o)shl 4+7)shl 4+2)shl 13 ; edit
	dd 4 shl 28 ; e
	dd (24o shl 5+21o)shl 22 ; lm
	dd (1 shl 5+21o)shl 23 ; rm
	dd ((((25o shl 4+1)shl 4+5)shl 7+142o)shl 7+144o)shl 5 ; graph ic
	dd (((2 shl 4+4)shl 7+145o)shl 4+2)shl 13 ; text
	dd ((((164o shl 4+4)shl 5+23o)shl 7+143o)shl 4+3)shl 5 ; keybo ard
	dd (((140o shl 4+4)shl 7+143o)shl 7+146o)shl 7 ; debu g
	dd (5 shl 4+2)shl 24 ; at
	dd ((173o shl 4+5)shl 4+2)shl 17 ; +at
	dd (145o shl 5+23o)shl 20 ; xy
	dd ((26o shl 4+3)shl 7+141o)shl 16 ; fov
	dd (((26o shl 4+7)shl 5+26o)shl 4+3)shl 14 ; fifo
	dd ((143o shl 4+3)shl 7+145o)shl 14 ; box
	dd (((24o shl 4+7)shl 4+6)shl 4+4)shl 15 ; line
	dd ((((22o shl 4+3)shl 5+24o)shl 4+3)shl 4+1)shl 10 ; color
	dd (((((3 shl 5+22o)shl 4+2)shl 4+5)shl 4+6)shl 4+2)shl 7 ; octant
	dd (20o shl 7+142o)shl 20 ; sp
	dd (((24o shl 4+5)shl 5+20o)shl 4+2)shl 14 ; last
	dd (((((146o shl 4+6)shl 7+142o)shl 4+5)shl 5+22o))shl 5 ; unpac k


; [Refs: start1]
forth1	dd 512 dup (0)


; [Refs: qcompile, compile]
macro2	dd offset semi
	dd offset cdup
	dd offset qdup
	dd offset cdrop
	dd offset then
	dd offset begin
	dd 128 dup (0)


; [Refs: ex1, ex2, forthd, variable, qcompile]
forth2	dd offset boot
	dd offset warm
	dd offset pause
	dd offset macro_
	dd offset forth
	dd offset c_
	dd offset stop
	dd offset readf
	dd offset writef
	dd offset nc_
	dd offset cmdf
	dd offset seekf
	dd offset readyf
	dd offset act
	dd offset show
	dd offset load
	dd offset here
	dd offset qlit
	dd offset comma3
	dd offset comma2
	dd offset comma1
	dd offset comma
	dd offset less
	dd offset jump
	dd offset accept
	dd offset pad
	dd offset erase
	dd offset copy
	dd offset mark
	dd offset empty
	dd offset emit
	dd offset edig
	dd offset emit2
	dd offset dot10
	dd offset hdot
	dd offset hdotn
	dd offset cr
	dd offset space
	dd offset down
	dd offset edit
	dd offset e
	dd offset lms
	dd offset rms
	dd offset graphic
	dd offset text1
	dd offset keyboard
	dd offset debug
	dd offset at
	dd offset pat
	dd offset xy_
	dd offset fov_
	dd offset fifof
	dd offset box
	dd offset line
	dd offset color
	dd offset octant
	dd offset sps
	dd offset last_
	dd offset unpack
	dd 512 dup (0)

; Utilities

; General-purpose routines

boot:
; Force a hardware reset.
; [Refs: forth2]
	mov	al, 0feh ; reset
	out	64h, al
	jmp	$

erase:
; ( b n -- ) Erase n blocks, starting with block b.
; [Refs: forth2]
	mov	ecx, eax
	shl	ecx, 8
	drop
	push	edi
	mov	edi, eax
	shl	edi, 2+8
	xor	eax, eax
	rep	stosd
	pop	edi
	drop
	ret

copy:
; ( n -- ) Copy current block to block n, and make that
;         block the current block.
; [Refs: forth2]
	cmp	eax, 12
	jc	abort1
	mov	edi, eax
	shl	edi, 2+8
	push	esi
	mov	esi, blk
	shl	esi, 2+8
	mov	ecx, 256
	rep	movsd
	pop	esi
	mov	blk, eax
	drop
	ret

debug:
; (?)Print four numbers --
; [Refs: forth2]
	mov	xy, 3*10000h+(vc-2)*ih+3
	dup_
	mov	eax, god
	push	[eax]
	call	dot
	dup_
	pop	eax
	call	dot
	dup_
	mov	eax, main
	call	dot
	dup_
	mov	eax, esi
	jmp	dot

; Screen variables
;
; Note the relationships among the variables and equates:
;
; The screen width (hp) is 1024 pixels; the screen height (vp) is 768 pixels.
;
; An "icon" is actually a glyph from the ColorForth font a bitmapped image of a
; character. An icon image is actually 16 pixels wide by 24 pixels high, but
; ColorForth puts six pixels of blank space between icons when "emitting" them to
; the screen, so iw (icon width) is 16+6, and ih is 24+6.
;
; The number of characters you can fit on a line on the screen (hc) is thus 46, and
; the number of lines you can fit on the screen (vc) is 25.
;
; The left margin (lm) is 3 pixels from the left edge of the screen. The right
; margin (rm) the X position beyond which characters must not be emitted is the
; character width times the number of characters per line, or 1012.
;
; The code to calculate an address in video memory implies that the video card
; reserves 64KB (0x10000 bytes) per scanline even though a 16-bit color mode
; requires only two bytes per pixel, the resolution requires 1024 pixels per
; scanline, and therefore you don't really need more than 2KB to store a scanline in
; main memory. This is probably another case of Chuck Moore tightly fitting his code
; to his own hardware his video card maps its onboard RAM (displ) to main-memory
; address 0xF0000000 and starts scanlines at addresses 0xF0010000, 0xF0020000, etc.

iw	equ 16+6
; [Refs: space, emit2, text1, hc, rm, keyboard, ring, type0]

ih	equ 24+6
; [Refs: debug, vc, down, cr, keyboard]

hc	equ hp/iw ; 46
; [Refs: rm, keyboard, text1]

vc	equ vp/ih ; 25
; [Refs: debug]

align 4

; [Refs: clip, space, emit2, line, debug, xy_, down, blank, top, qcr, cr, at,
;       pat, keyboard, ring, rw, type0]
xy	dd 3*10000h+3


; [Refs: text1, top, cr, lms, keyboard, rw]
lm	dd 3


; [Refs: text1, qcr, rms, keyboard, ring]
rm	dd hc*iw ; 1012


; [Refs: top]
xycr	dd 0


; [Refs: fov_]
fov	dd 10*(2*vp+vp/2)

; Getting variable addresses

nc_: ;"nc"
; [Refs: forth2]
	dup_
	mov	eax, (offset nc-offset start)/4
	ret

xy_: ;"xy"
; [Refs: forth2]
	dup_
	mov	eax, (offset xy-offset start)/4
	ret

fov_: ;"fov"
; [Refs: forth2]
	dup_
	mov	eax, (offset fov-offset start)/4
	ret

sps: ;"sp"
; [Refs: forth2]
	dup_
	mov	eax, (offset spaces-offset start)/4
	ret

last_: ;"last"
; [Refs: forth2]
	dup_
	mov	eax, (offset last-offset start)/4
	ret

; Screen
;
include gen.asm ; cce.asm pio.asm ati128.asm ati64.asm gen.asm

yellow equ 0ffff00h

cyan:
	dup_
	mov	eax, 0ffffh
	jmp	color

magenta:
	dup_
	mov	eax, 0ff00ffh
	jmp	color

silver:
	dup_
	mov	eax, 0c0c0c0h
	jmp	color

blue:
	dup_
	mov	eax, 4040ffh
	jmp	color

red:
	dup_
	mov	eax, 0ff0000h
	jmp	color

green:
	dup_
	mov	eax, 8000ff00h
	jmp	color

;.............................................................................
; Refs:
; -- yellow: keyc, ww, nw1, actc, e, eout
; -- cyan: mw
; -- magenta: var, actv
; -- silver: none
; -- blue: none
; -- red: rw
; -- green: gw



; [Refs: echo_, right, keyboard]
history	db 11 dup (0)

echo_:
; [Refs: abort1, word1]
	push	esi
	mov	ecx, 11-1
	lea	edi, history
	lea	esi, [1+edi]
	rep	movsb
	pop	esi
	mov	history+11-1, al
	drop
	ret

right:
; [Refs: x, word_]
	dup_
	mov	ecx, 11
	lea	edi, history
	xor	eax, eax
	rep	stosb		; store al into [edi] ecx times
; therefore "right" just fills the "history" buffer (11 bytes) with zeroes.
	drop
	ret

down:
; [Refs: forth2]
	dup_			; push TOS
	xor	edx, edx	; clear high 32 bits of dividend
	mov	ecx, ih		; get icon height as divisor
	div	ecx		; TOS/ih = eax:quo edx:rem
	mov	eax, edx	; TOS = rem (overwrite quo)
	add	edx, 3*10000h+8000h-ih+3	;x = 3, y = rem - 22 * ih ???
	mov	xy, edx		; set xy and fall through to zero...

zero:
; If TOS=0, set TOS and ZF to 1; otherwise set both to 0.
; [Refs: none]
	test	eax, eax
	mov	eax, 0
	jnz	@f
	inc	eax
@@:	ret

blank:
; Blanks the screen (draws a black box over the whole screen).
; [Refs: refresh]
	dup_
	xor	eax, eax
	mov	xy, eax
	call	color
	dup_
	mov	eax, hp
	dup_
	mov	eax, vp
	jmp	box

top:
; Sets cursor position to top-left corner.
; [Refs: text1]
	mov	ecx, lm
	shl	ecx, 16   ; Make offset from video-memory start to scanline.
	add	ecx, 3    ; Add padding between left margin and first icon.
	mov	xy, ecx
	mov	xycr, ecx
	ret

qcr:
; [Refs: emit]
	mov	cx, word ptr xy+2	; get x
	cmp	cx, word ptr rm		; x>rm?
	js	@f			; if so, do CR

cr:
; [Refs: forth2, keyboard, rw]
	mov	ecx, lm
	shl	ecx, 16			; x=lm
	mov	cx, word ptr xy		; get y
	add	ecx, ih			; y=y+ih
	mov	xy, ecx			; set xy
@@:	ret

; Setting screen parameters

lms: ;"lm"
; Set left margin.
	mov	lm, eax
	drop
	ret

rms: ;"rm"
; Set right margin.
	mov	rm, eax
	drop
	ret

at:
; Set screen position.
	mov	word ptr xy, ax
	drop
	mov	word ptr xy+2, ax
	drop
	ret

pat: ;"+at"
; Set screen position relative to current position.
	add	word ptr xy, ax
	drop
	add	word ptr xy+2, ax
	drop
	ret

;.............................................................................
; Refs:
; -- lms: forth2
; -- rms: forth2
; -- at: forth2
; -- pat: forth2

; Octant

octant:
; ( -- ?? ) ??
; [Refs: forth2]
	dup_
	mov	eax, 43h ; poly -last y+ x+ ;23h ; last y+ x+
	mov	edx, [4+esi]   ; (if bit 31 in 2nd arg not set, return)
	test	edx, edx
	jns	@f
	neg	edx            ; (negate 2nd arg)
	mov	[4+esi], edx
	xor	al, 1          ; (toggle bit 0)
@@:	cmp	edx, [esi]     ; (cmp modified 2nd arg, 1st arg)
	jns	@f             ; (if edx - [esi] signed,)
	xor	al, 4          ;    (toggle bit 2)
@@:	ret

; Drawing the user interface

; keyboard
eight:
; Prints one line of the keyboard "map"
; in the lower-right corner of the screen.
; [Refs: keyboard]
	add	edi, 12
	call	four
	call	space
	sub	edi, 16

four:
; [Refs: eight]
	mov	ecx, 4

four1:
; [Refs: four1, keyboard]
	push	ecx
	dup_
	xor	eax, eax
	mov	al, [4+edi]
	inc	edi
	call	emit
	pop	ecx
	next	four1
	ret

stack:
; (?)Retrieves items from stack and prints them one by one?
; [Refs: keyboard]
	mov	edi, godd-4
@@:	mov	edx, god
	cmp	[edx], edi
	jnc	@f
	dup_
	mov	eax, [edi]
	sub	edi, 4
	call	qdot
	jmp	@b
@@:	ret

keyboard:
; [Refs: forth2, type0]
	call	text1
	mov	edi, board
	dup_
	mov	eax, keyc
	call	color
	mov	rm, hc*iw
	mov	lm, hp-9*iw+3
	mov	xy, (hp-9*iw+3)*10000h+vp-4*ih+3
	call	eight
	call	eight
	call	eight
	call	cr
	add	xy, 4*iw*10000h
	mov	edi, shift
	add	edi, 4*4-4
	mov	ecx, 3
	call	four1
	mov	lm, 3
	mov	word ptr xy+2, 3
	call	stack
	mov	word ptr xy+2, hp-(11+9)*iw+3
	lea	edi, history-4
	mov	ecx, 11
	jmp	four1

; Editor
;
; Keyboard handling
;
; ColorForth draws a keyboard map in the lower-right corner of the screen, so that
; the user can see what characters will appear as he types. ColorForth draws the map
; from one of the following four tables. ColorForth also uses the tables to
; determine what character to generate when a particular key is pressed.
;
; Any reference to one of these tables is actually a reference to an address four
; bytes before the table, e.g., "alpha-4", "graphics-4", etc. The reason for this is
; that the key codes 4 through 27 are used as offsets into these tables.
;
; The byte values in these tables are ColorForth character codes (octal values 0
; through 57o).
;
; (Say when each of the four tables is active, e.g., what keys have to be held down
; or pressed.)


; [Refs: board, acceptn, alph0, alph]
alpha	db 15o, 12o,  1 , 14o ;   g c r l		; -16
	db 24o,  2 ,  6 , 10o ;   h t n s
	db 23o, 11o, 17o, 21o ;   b m w v
	db 22o, 13o, 16o,  7  ;   p y f i		; +12 
	db  5 ,  3 ,  4 , 26o ;   a o e u
	db 27o, 44o, 25o, 20o ;   q k x d


; [Refs: star0, graph]
graphics	db 31o, 32o, 33o,  0  ;   1 2 3
	db 34o, 35o, 36o, 30o ;   4 5 6 0
	db 37o, 40o, 41o, 57o ;   7 8 9 ?
	db 51o, 50o, 52o, 54o ;   : ; ! @
	db 46o, 42o, 45o, 56o ;   z j . ,
	db 55o, 47o, 53o, 43o ;   * / + -


; [Refs: decimal]
numbers	db 31o, 32o, 33o,  0  ;   1 2 3
	db 34o, 35o, 36o, 30o ;   4 5 6 0
	db 37o, 40o, 41o,  0  ;   7 8 9
	db  0,   0 ,  0 ,  0
	db  0,   0 ,  0 ,  0
	db  0,   0 ,  0 ,  0


; [Refs: hex]
octals	db 31o, 32o, 33o,  0  ;   1 2 3
	db 34o, 35o, 36o, 30o ;   4 5 6 0
	db 37o, 40o, 41o,  0  ;   7 8 9
	db  0 ,  5 , 23o, 12o ;     a b c
	db  0 , 20o,  4 , 16o ;     d e f
	db  0 ,  0 ,  0 ,  0

; Letter is passed a ColorForth key code (pulled from keys). If the key pressed is
; either an undefined key (code=0), the N key (code=1), the spacebar (code=2), or
; either Alt key (code=3), then letter replaces the key code with [edx+eax] =
; [board+code]. Otherwise, letter returns the key code unchanged.

letter:
; [Refs: word1, number3]
	cmp	al, 4
	js	@f
	mov	edx, board
	mov	al, [edx][eax]
@@:	ret

; Reading the keyboard
;
; The key routine reads Set 1 scan codes from the keyboard controller, subtracts
; sixteen (20o or 0x10), and uses the result as an offset into the keys table, which
; contains ColorForth-specific key codes. ColorForth recognizes only Set 1 scan
; codes in the range 0x10 through 0x39 (20o through 71o in octal), a range
; containing forty-one keys. In fact, ColorForth recognizes only twenty-seven of
; these keys.


; [Refs: key]
keys	db 16, 17, 18, 19,  0,  0,  4,  5 ; 20   ; Keys: QWER--UI
	db  6,  7,  0,  0,  0,  0, 20, 21        ;       OP----AS
	db 22, 23,  0,  0,  8,  9, 10, 11 ; 40   ;       DF--JKL;
	db  0,  0,  0,  0, 24, 25, 26, 27        ;       ----ZXCV
	db  0,  1, 12, 13, 14, 15,  0,  0 ; 60 n ;       -NM<>?--
	db  3,  2 ; alt space                    ;       [Alt] [Space]

; There are twenty-eight ColorForth-specific key codes. The blue cells are for keys 
; you press with your right thumb; the green, for keys you press with the four 
; fingers on your right hand; the red, for keys you press with the four fingers on 
; your left hand. 
;
; Key code Key		Key code Key		Key code Key
; 0 Unused key		10	L		20	A
; 1 N			11	;		21	S
; 2 Space		12	M		22	D
; 3 Alt			13	<		23	F
; 4 U			14	>		24	Z
; 5 I			15	?		25	X
; 6 O			16	Q		26	C
; 7 P			17	W		27	V
; 8 J			18	E
; 9 K			19	R
;
; So we can see what characters are produced for each of the four keyboard modes. In 
; alpha mode, the keyboard looks like this (the large character is the one produced 
; by the key; the small character is the one printed on the key; the gray cells 
; indicate keys that don't produce any characters): 
;
; y f i     g c r l
; Q W E R T Y U I O P
;
; o e u     h t n s
; A S D F G H J K L ; 
;
; k x d     b m w v
; Z X C V B N M < > ?
; 
; In graphics mode, the keyboard looks like this: 
;
; ; ! @     1 2 3
; Q W E R T Y U I O P
;
; J . ,     4 5 6 0
; A S D F G H J K L ; 
;
; / + -     7 8 9 ?
; Z X C V B N M < > ?
; 
; In numbers mode, the keyboard looks like this: 
;
;           1 2 3
; Q W E R T Y U I O P
;
;           4 5 6 0
; A S D F G H J K L ; 
;
;           7 8 9  
; Z X C V B N M < > ?
; 
; In hexadecimal mode, the keyboard looks like this: 
;
; a b c     1 2 3
; Q W E R T Y U I O P
;
; d e f     4 5 6 0
; A S D F G H J K L ; 
;
;           7 8 9  
; Z X C V B N M < > ?
; 
; Key waits for a key, then returns the key code (a number in the range 0..27). It
; first calls pause to let the other task run, then checks the key port to see if a
; key has been pressed. If not, key keeps calling pause and checking the key port
; until a key is pressed.
;
; If a key is pressed, the scan code must be between 20o (0x10) and 71o (0x39), or
; else the key is ignored key calls pause and checks the key port again. If the
; scan code is acceptable, key uses it to grab the ColorForth key code from the keys
; table.

key:
; [Refs: accept1, word0, number3, e, pad]
	dup_
	xor	eax, eax
@@:	call	pause
	in	al, 144o
	test	al, 1
	jz	@b
	in	al, 140o
	test	al, 360o     ; If scan code is 0..15,
	jz	@b           ;   ignore it.
	cmp	al, 72o      ; If scan code >= 72o (0x3A = caps lock),
	jnc	@b           ;   ignore it.
	mov	al, [keys-20o+eax]
	ret

; -- 6 tables, pointed to by shift -- these deal only with the "shift" keys,
; 0=undefined key, 1=N, 2=space, 3=alt -- db bytes are CF char codes --

align 4

; [Refs: star0]
graph0	dd offset nul0, offset nul0, offset nul0, offset alph0		; displayed when entering extended letters
	db  0 ,  0 ,  5 , 0 						;     a


; [Refs: graph]
graph1	dd offset word0, offset x, offset lj, offset alph		; displayed when ...???
	db 25o, 45o,  5 , 0 						; x . a


; [Refs: shift, acceptn, alph0, e, eout]
alpha0	dd offset nul0, offset nul0, offset number, offset star0	; displayed when entering main letters
	db  0 , 41o, 55o, 0 						;   9 *


; [Refs: alph]
alpha1	dd offset word0, offset x, offset lj, offset graph		; displayed when ...???
	db 25o, 45o, 55o, 0 						; x . *


; [Refs: decimal, hex, octal]
numb0	dd offset nul0, offset minus, offset alphn, offset octal	; displayed when entering positive numbers
	db 43o,  5 , 16o, 0 						; - a f


; [Refs: number2]
numb1	dd offset number0, offset xn, offset endn, offset number0	; displayed when entering negative numbers
	db 25o, 45o,  0 , 0 						; x .

; pointer to data structure of four offsets to key handling routines
; followed by four bytes: the characters to print as the keyboard
; guide in the lower-right corner of the screen.
; [Refs: keyboard, letter, accept1, decimal, hex, graph, e, pad]
board	dd offset alpha-4

; Shift generally points to one of the following tables:
; alpha0, alpha1, graph0, graph1, numb0, numb1.


; [Refs: keyboard, acceptn, accept1, word1, decimal, hex, number3, number2,
;       alph0, star0, alph, graph, first, e, pad]
shift	dd offset alpha0

; ColorForth displays numbers in one of two formats decimal and hexadecimal.
; Decimal stores 10 here; hex stores 16 here. Therefore routines with "cmp base, 10
; : jz base10" fall into handling hexadecimal.

; [Refs: decimal, hex, number3, qdot, format, format2]
base	dd 10

; "current" not changed, always points to decimal


; [Refs: octal, number]
current	dd offset decimal

; current key color?
; [Refs: keyboard, actn, e, eout]
keyc	dd yellow


; [Refs: word_, word1]
chars	dd 1


; [Refs: first, act7, actv, eout]
aword	dd offset ex1


; [Refs: endn, e, eout]
anumber	dd offset nul


; [Refs: ex1, full, x, word_, actv, destack, insert0, insert1, format, format2]
words	dd 1

nul0:
; [Refs: graph0, alpha0, numb0, eout]
	drop
	jmp	@f

accept:
; [Refs: start1, abort1, forth2, x, first, actn, eout, insert]
acceptn:
; [Refs: xn, endn]
	mov	shift, offset alpha0
	lea	edi, alpha-4

; "Key" returns in AL a number 0..27. If number is 4..27, jump to first -- otherwise
; convert AL into an offset into whichever of the six tables [each with four DD's]
; "shift" is pointing to, and jump to the address in the table.

accept1:
; [Refs: star0]
	mov	board, edi
@@:	call	key
	cmp	al, 4
	jns	first
	mov	edx, shift
	jmp	dword ptr [edx+eax*4]

; Pre-parsing words
;
; Pack takes a single character (first item on stack), converts it into a pre-
; parsed-source bit pattern, and adds the bit pattern to a pre-parsed word (second
; item on stack), if the word is full already, a new word is started.


; [Refs: pack, lj0, full, word_]
bits	db 28

; This is part of the "pack" routine.
@@:	add	eax, 120o
	mov	cl, 7
	jmp	@f

pack:
; [Refs: word1]
	cmp	al, 20o                ; If character is 20o or higher,
	jnc	@b                     ;   go to section above.
	mov	cl, 4                  ; Assume character size of 4 bits.
	test	al, 10o                ; If character is 10o..17o, then
	jz	@f
	inc	ecx                    ;   set character size to 5 bits and
	xor	al, 30o                ;   change character to bitpattern.
@@:	mov	edx, eax               ; (save) ???
	mov	ch, cl                 ; (save) ???
@@:	cmp	bits, cl
	jnc	@f
	shr	al, 1
	jc	full
	dec	cl
	jmp	@b
@@:	shl	dword ptr [esi], cl ;
	xor	[esi], eax
	sub	bits, cl
	ret

lj0:
; "Left-justifies" bits by shifting them left,
;  so that the leftmost bit is in bit 31.
; [Refs: lj, full]
	mov	cl, bits
	add	cl, 4
	shl	dword ptr [esi], cl
	ret

lj:
; [Refs: graph1, alpha1]
	call	lj0
	drop
	ret

full:
; Finish packing a pre-parsed word.
; [Refs: pack]
	call	lj0
	inc	words
	mov	bits, 28
	sub	bits, ch
	mov	eax, edx
	dup_
	ret


x:
; [Refs: graph1, alpha1]
	call	right
	mov	eax, words
	lea	esi, [eax*4+esi]
	drop
	jmp	accept

word_:
; [Refs: first]
	call	right
	mov	words, 1
	mov	chars, 1
	dup_
	mov	dword ptr [esi], 0
	mov	bits, 28

word1:
; [Refs: word0]
	call	letter
	jns	@f
	mov	edx, shift
	jmp	dword ptr [edx+eax*4]
@@:	test	al, al
	jz	word0
	dup_
	call	echo_
	call	pack
	inc	chars

word0:
; [Refs: graph1, alpha1, word1, graph]
	drop
	call	key
	jmp	word1

decimal:
; [Refs: current, octal]
	mov	base, 10
	mov	shift, offset numb0
	mov	board, offset numbers-4
	ret

hex:
; [Refs: octal]
	mov	base, 16
	mov	shift, offset numb0 ; oct0
	mov	board, offset octals-4
	ret

octal:
; [Refs: numb0]
	xor	current, (offset decimal-offset start) xor (offset hex-offset start)
	xor	byte ptr numb0+18, 41o xor 16o ; f vs 9
	call	current
	jmp	number0

xn:
; [Refs: numb1]
	drop
	drop
	jmp	acceptn
;	db  0,  0,  0,  0


; [Refs: number3]
digit	db 14, 10,  0,  0
	db  0,  0, 12,  0,  0,  0, 15,  0
	db 13,  0,  0, 11,  0,  0,  0,  0
	db  0,  1,  2,  3,  4,  5,  6,  7
	db  8,  9


; [Refs: minus, number, number3]
sign	db 0

minus:
; [Refs: numb0]
	; mov	al, 43o ; -
	mov	sign, al
	jmp	number2

number0:
; [Refs: numb1, octal, number3]
	drop
	jmp	number3

number:
; [Refs: alpha0]
	call	current
	mov	sign, 0
	xor	eax, eax

number3:
; [Refs: number2, number0]
	call	key
	call	letter
	jns	@f
	mov	edx, shift
	jmp	dword ptr [edx+eax*4]
@@:	test	al, al
	jz	number0
	mov	al, [digit-4+eax]
	test	sign, 37o
	jz	@f
	neg	eax
@@:	mov	edx, [esi]
	imul	edx, base
	add	edx, eax
@@:	mov	[esi], edx

number2:
; [Refs: minus]
	drop
	mov	shift, offset numb1
	jmp	number3

endn:
; [Refs: numb1]
	drop
	call	[anumber]
	jmp	acceptn

alphn:
; [Refs: numb0]
	drop

alph0:
; [Refs: graph0]
	mov	shift, offset alpha0
	lea	edi, alpha-4
	jmp	@f

star0:
; [Refs: alph0]
	mov	shift, offset graph0
	lea	edi, graphics-4
@@:	drop
	jmp	accept1

alph:
; [Refs: graph1]
	mov	shift, offset alpha1
	lea	edi, alpha-4
	jmp	@f

graph:
; [Refs: alpha1]
	mov	shift, offset graph1
	lea	edi, graphics-4
@@:	mov	board, edi
	jmp	word0

first:
; [Refs: accept1]
	add	shift, 4*4+4
	call	word_
	call	[aword]
	jmp	accept

; Printing numbers


; Character codes for the sixteen hexadecimal digits.
; [Refs: edig]
hicon	db 30o, 31o, 32o, 33o, 34o, 35o, 36o, 37o ; 01234567
	db 40o, 41o,  5 , 23o, 12o, 20o,  4 , 16o ; 89abcdef

; Edig1 ( n -- n ) and edig ( n -- ) emit a hexadecimal digit. The top item on the
; stack is expected to be a number between 0 and 15, which is used as an offset into
; the hicon table.

edig1:
; [Refs: d_1, d_2]
	dup_

edig: ;"digit"
; [Refs: forth2, hdot, dot]
	push	ecx
	mov	al, hicon[eax]
	call	emit
	pop	ecx
	ret

; Odig ( x -- y n ) converts the next four bits in a 32-bit number into a value
; between 0 and 15 (suitable for being passed to edig). Note that, immediately after
; the call to odig, the caller can test the zero flag to see if the value is zero.

odig:
; [Refs: hdot, dot]
	rol	eax, 4
	dup_
	and	eax, 0fh
	ret

; ??? Print only bottom N hex digits of number ???

hdotn: ;"h.n"
; [Refs: forth2]
	mov	edx, eax
	neg	eax
	lea	ecx, [32+eax*4]
	drop
	rol	eax, cl
	mov	ecx, edx
	jmp	@f

; Print 32-bit number onto screen as eight-digit hexadecimal number (pad with
; leading zeroes if necessary).

hdot: ;"h."
; [Refs: forth2]
	mov	ecx, 8
@@:	call	odig
	call	edig
	next	@b
	drop
	ret

; Print 32-bit number onto screen as hexadecimal number without leading zeroes.

dot:
; [Refs: debug, qdot, ref1]
	mov	ecx, 7
@@:	call	odig
	jnz	@h         ; Branch on first nonzero digit.
	drop	           ; Drop leading zero.
	next	@b
	inc	ecx        ; If number = 0, digit count = 1 (print "0").

@@:	call	odig       ; Get next hexadecimal digit.
@h1:	call	edig       ; Output digit.
	next	@b         ; Continue until there are no more digits.
	call	space
	drop
	ret

@h:	inc	ecx        ; (Go from handling leading zeroes
	jmp	@h1        ;   to handling nonzero digits.)

; Print 32-bit number onto screen without leading zeroes as a decimal or a
; hexadecimal number, depending on the current base.

qdot:
; [Refs: stack]
	cmp	base, 10
	jnz	dot

dot10: ;"."
; (?)Prints a decimal number.
; [Refs: forth2, gnw1, nw1, ref1, bas]
	mov	edx, eax
	test	edx, edx
	jns	@f
	neg	edx          ; Negate number.
	dup_
	mov	eax, 43o     ; Print minus sign.
	call	emit
@@:	mov	ecx, 8
@@:	mov	eax, edx
	xor	edx, edx
	div	tens[ecx*4] ; NASM "div [tens+ecx*4]
	test	eax, eax
	jnz	d_1
	dec	ecx
	jns	@b
	jmp	d_2
@@:	mov	eax, edx
	xor	edx, edx
	div	tens[ecx*4] ; NASM "div [tens+ecx*4]

d_1:
; [Refs: dot10]
	call	edig1
	dec	ecx
	jns	@b

d_2:
; [Refs: dot10]
	mov	eax, edx
	call	edig1
	call	space ; spcr
	drop
	ret

; Display routines
;
; unpack
;
; You push a "word" (a 32-bit cell of pre-parsed source code) onto the stack before
; calling unpack. Unpack removes the first character from this word (e.g., "pack"
; becomes "ack") but leaves the word on the stack. Unpack then pushes the removed
; character onto the stack.

unpack: ; ( w -- w c )
; [Refs: forth2, cap, caps, type2]
	dup_
	test	eax, eax            ; Four-bit character begins with 0.
	js	@f                  ; Branch if character begins with 1.
	shl	dword ptr [esi], 4  ; Remove 4-bit character from word.
	rol	eax, 4              ; Convert character into character
	and	eax, 7              ;   code (0..7).
	ret

@@:	shl	eax, 1              ; Five-bit character begins with 10.
	js	@f                  ; Branch if character begins with 11.
	shl	dword ptr [esi], 5  ; Remove 5-bit character from word.
	rol	eax, 4              ; Convert character into character
	and	eax, 7              ;   code (10o..17o).
	xor	al, 10o             ; (Flip bit 3 = set bit 3 = add 8.)
	ret

@@:	shl	dword ptr [esi], 7  ; Remove 7-bit character from word.
	rol	eax, 6              ; Convert character into character
	and	eax, 77o            ;   code (20o..57o).
	sub	al, 20o
	ret

; qring and ring -- I believe the "ring" is character 60o --  -- ColorForth uses
; this instead of a blinking cursor to indicate where the next word will appear in
; the editor

qring:
; [Refs: type0, ref1]
	dup_
	inc	dword ptr [esi]
	cmp	curs, edi ; from abort, insert
	jnz	@f
	mov	curs, eax		
@@:	cmp	eax, curs
	jz	ring
	jns	@f
	mov	pcad, edi
@@:	drop
	ret

ring:
; [Refs: qring]
	mov	cad, edi
	sub	xy, iw*10000h ; bksp
	dup_
	mov	eax, 0e04000h
	call	color
	mov	eax, 60o
	mov	cx, word ptr xy+2
	cmp	cx, word ptr rm
	js	@f
	call	emit
	sub	xy, iw*10000h ; bksp
	ret
@@:	jmp	emit

; The refresh routine (actually ref1) relies on thirteen other routines (not
; counting nul, which does nothing) to display pre-parsed words on the screen. These
; routines correspond to the thirteen colors defined in the pre-parsed word specs.
;
; Color number Color Meaning Label Probable label meaning
; 0 N/A Extension TYPE0 Show type-0 word
; 1 Yellow Execute word wW Show word as Word
; 2 Yellow Execute "long" number nW Show number as Word
; 3 Red Define word rW Show red Word
; 4 Green Compile word gW Show green Word
; 5 Green Compile "long" number gnW Show green number as Word
; 6 Green Compile "short" number gsW Show green short number as Word
; 7 Cyan Compile macro word mW Show macro Word
; 8 Yellow Execute "short" number sW Show short number as Word
; 9 White Comment (lowercase) text Show text
; 10 White Comment (Capitalized) Cap Show text Capitalized
; 11 White Comment (ALL CAPS) CAPS Show text in ALL CAPS
; 12 Magenta Variable var Show variable
; 13 nul
; 14 nul
; 15 nul
;
; Displaying words

; Red word
rw:
; [Refs: display]
	mov	cx, word ptr xy+2
	cmp	cx, word ptr lm
	jz	@f
	call	cr
@@:	call	red
	jmp	type_

; Green word
gw:
; [Refs: display]
	call	green
	jmp	type_

; Macro word
mw:
; [Refs: display]
	call	cyan
	jmp	type_

; Word word
ww:
; [Refs: display]
	dup_
	mov	eax, yellow
	call	color
	jmp	type_

; Displaying word extensions

; Display a type 0 word
type0:
; [Refs: display]
	sub	xy, iw*10000h ; call bspcr
	test	dword ptr [-4+edi*4], -20o
	jnz	type1
	dec	edi
	mov	lcad, edi
	call	space
	call	qring
	pop	edx ; end of block ; [RST]
	drop
	jmp	keyboard

; Displaying comments

; Initial character capitalized comment word (white)
cap:
; [Refs: display]
	call	white
	dup_
	mov	eax, [-4+edi*4]
	and	eax, -20o
	call	unpack
	add	al, 48
	call	emit
	jmp	type2

; All capitals comment word (white)
caps:
; [Refs: display]
	call	white
	dup_
	mov	eax, [-4+edi*4]
	and	eax, -20o
@@:	call	unpack
	jz	@f
	add	al, 48
	call	emit
	jmp	@b

; Comment word (white)
text:
; [Refs: display]
	call	white

; Unpacking and printing characters

type_:
; [Refs: var, rw, gw, mw, ww]
type1:
; [Refs: type0]
	dup_
	mov	eax, [-4+edi*4]
	and	eax, -20o

type2:
; [Refs: cap, type2]
	call	unpack
	jz	@f
	call	emit
	jmp	type2
@@:	call	space
	drop
	drop
	ret

; Displaying numbers

; Green short word
gsw:
; [Refs: display]
	mov	edx, [-4+edi*4]
	sar	edx, 5
	jmp	gnw1

; Variable word (magenta)
;  falls through to a green number word
var:
; [Refs: display]
	call	magenta
	call	type_

; Green number word
gnw:
; [Refs: display]
	mov	edx, [edi*4]
	inc	edi

gnw1:
; [Refs: gsw]
	dup_
	mov	eax, 0f800h ; green
	cmp	bas, offset dot10
	jz	@f		
	mov	eax, 0c000h ; dark green
	jmp	@f	; into nw1

; Short number word (yellow)
sw:
; [Refs: display]
	mov	edx, [-4+edi*4]
	sar	edx, 5
	jmp	nw1

; Number word (yellow)
nw:
; [Refs: display]
	mov	edx, [edi*4]
	inc	edi

nw1:
; [Refs: sw]
	dup_
	mov	eax, yellow
	cmp	bas, offset dot10
	jz	@f		
	mov	eax, 0c0c000h ; dark yellow
@@:	call	color
	dup_
	mov	eax, edx
	jmp	[bas]

; Refresh

refresh:
; [Refs: e]
	call	show
	call	blank
	call	text1
	dup_			; counter
	mov	eax, lcad
	mov	cad, eax ; for curs beyond end
	xor	eax, eax
	mov	edi, blk
	shl	edi, 10-2
	mov	pcad, edi ; for curs=0

ref1:
; [Refs: ref1]
	test	dword ptr [edi*4], 0fh
	jz	@f
	call	qring
@@:	mov	edx, [edi*4]
	inc	edi
	mov	bas, offset dot10
	test	dl, 20o
	jz	@f
	mov	bas, offset dot
@@:	and	edx, 17o
	call	display[edx*4]
	jmp	ref1

; The display-routine table

align 4

; Offsets to display routines.
; [Refs: ref1]
display	dd offset type0, offset ww, offset nw, offset rw
	dd offset gw, offset gnw, offset gsw, offset mw
	dd offset sw, offset text, offset cap, offset caps
	dd offset var, offset nul, offset nul, offset nul

; [Refs: dot10]
tens	dd 10, 100, 1000, 10000, 100000, 1000000
	dd 10000000, 100000000, 1000000000


; [Refs: gnw1, nw1, ref1]
bas	dd offset dot10

; blk is the current block


; [Refs: abort, copy, refresh, pblk, mblk, shadow, edit, e]
blk	dd 18


; [Refs: abort, qring, (refresh,) mcur, pcur, mmcur, ppcur, insert1]
curs	dd 0


; [Refs: ring, refresh, insert1, del, enstack]
cad	dd 0


; [Refs: qring, refresh, del, enstack]
pcad	dd 0


; [Refs: type0, refresh, insert0, insert1, del]
lcad	dd 0


; [Refs: destack, enstack]
trash	dd buffer*4

; (27 keys in keyboard; 28 offsets in "ekeys" table)


; [Refs: e]
ekeys	dd offset nul, offset del, offset eout, offset destack
	dd offset act1, offset act3, offset act4, offset shadow
	dd offset mcur, offset mmcur, offset ppcur, offset pcur
	dd offset mblk, offset actv, offset act7, offset pblk
	dd offset nul, offset act11, offset act10, offset act9
	dd offset nul, offset nul, offset nul, offset nul


; [Refs: e]
ekbd0	dd offset nul, offset nul, offset nul, offset nul
	db 25o, 45o,  7 ,  0  ;   x  .  I


; [Refs: e]
ekbd	db 17o,  1 , 15o, 55o ;   w  r  g  *
	db 14o, 26o, 20o,  1  ;   l  u  d  r
	db 43o, 11o, 12o, 53o ;   -  m  c  +
	db  0 , 70o, 72o,  2  ;	     s  c  t
	db  0 ,  0 ,  0 ,  0
	db  0 ,  0 ,  0 ,  0


; Action colors.
; [Refs: act7]
actc	dd yellow, 0, 0ff0000h, 0c000h, 0, 0, 0ffffh
		; 1=yellow (0xFFFF00), --, 3=red (0xFF0000),
		; 4=green (0x00C000), --, --, 7=cyan (0x00FFFF)
	dd 0, 0ffffffh, 0ffffffh, 0ffffffh, 8080ffh
		; --, 9..11=white (0xFFFFFF), 12=light blue??? (0x8080FF)


; [Refs: pad]
vector	dd 0

; These "actxxx" routines and variables wouldn't be connected with act, would they?


; [Refs: act7, actv, insert, format, format2]
action	db 1

act1:
; [Refs: ekeys]
	mov	al, 1                ; 1 = execute (yellow word)
	jmp	@f

act3:
; [Refs: ekeys]
	mov	al, 3                ; 3 = define (red word)
	jmp	@f

act4:
; [Refs: ekeys]
	mov	al, 4                ; 4 = compile (green word)
	jmp	@f

act9:
; [Refs: ekeys]
	mov	al, 9                ; 9 = comment (white word)
	jmp	@f

act10:
; [Refs: ekeys]
	mov	al, 10               ; 10 = Capitalized Comment
	jmp	@f

act11:
; [Refs: ekeys]
	mov	al, 11               ; 11 = COMMENT IN ALL CAPS
	jmp	@f

act7:
; [Refs: ekeys]
	mov	al, 7                ; 7 = compile macro (cyan word)
@@:	mov	action, al
	mov	eax, [actc-4+eax*4]
	mov	aword, offset insert

actn:
; [Refs: actv]
	mov	keyc, eax
	pop	eax ; [RST]
	drop
	jmp	accept

actv:
; [Refs: ekeys]
	mov	action, 12           ; 12 = variable (magenta word)
	mov	eax, 0ff00ffh ; magenta
	mov	aword, offset @f
	jmp	actn
@@:	dup_
	xor	eax, eax
	inc	words
	jmp	insert

; Cursor and block routines

mcur:
; [Refs: ekeys, del]
	dec	curs
	jns	@f

pcur:
; [Refs: ekeys]
	inc	curs
@@:	ret

mmcur:
; [Refs: ekeys]
	sub	curs, 8
	jns	@f
	mov	curs, 0
@@:	ret

ppcur:
; [Refs: ekeys]
	add	curs, 8
	ret

pblk:
; [Refs: ekeys]
	add	blk, 2
	add	dword ptr [esi], 2
	ret

mblk:
; [Refs: ekeys]
	cmp	blk, 20
	js	@f
	sub	blk, 2
	sub	dword ptr [esi], 2
@@:	ret

shadow:
; Toggles between code (even-numbered)
; and documentation (odd-numbered) blocks.
; [Refs: ekeys]
	xor	blk, 1
	xor	dword ptr [esi], 1
	ret


e0:
; [Refs: e]
	drop
	jmp	@f

edit:
; Start editor at block given in TOS.
; [Refs: forth2]
	mov	blk, eax
	drop

e:
; Restart editor at current block.
; [Refs: forth2]
	dup_
	mov	eax, blk
	mov	anumber, offset format
	mov	byte ptr alpha0+4*4, 45o ; .
	mov	alpha0+4, offset e0
	call	refresh
@@:	mov	shift, offset ekbd0
	mov	board, offset ekbd-4
	mov	keyc, yellow
@@:	call	key
	call	ekeys[eax*4]		; index into ekeys
	drop
	jmp	@b

eout:
; [Refs: ekeys]
	pop	eax ; [RST]
	drop
	drop
	mov	aword, offset ex1
	mov	anumber, offset nul
	mov	byte ptr alpha0+4*4, 0
	mov	alpha0+4, offset nul0
	mov	keyc, yellow
	jmp	accept

destack:
; [Refs: ekeys]
	mov	edx, trash
	cmp	edx, buffer*4
	jnz	@f
	ret
@@:	sub	edx, 2*4
	mov	ecx, [edx+1*4]
	mov	words, ecx
@@:	dup_
	mov	eax, [edx]
	sub	edx, 1*4
	next	@b
	add	edx, 1*4
	mov	trash, edx

insert0:
; [Refs: insert]
	mov	ecx, lcad ; room available?
	add	ecx, words
	xor	ecx, lcad
	and	ecx, -100h
	jz	insert1
	mov	ecx, words ; no
@@:	drop
	next	@b
	ret

insert1:
; [Refs: insert0]
	push	esi
	mov	esi, lcad
	mov	ecx, esi
	dec	esi
	mov	edi, esi
	add	edi, words
	shl	edi, 2
	sub	ecx, cad
	js	@f
	shl	esi, 2
	std
	rep	movsd
	cld
@@:	pop	esi
	shr	edi, 2
	inc	edi
	mov	curs, edi ; like abort
	mov	ecx, words
@@:	dec	edi
	mov	[edi*4], eax
	drop ; requires cld
	next	@b
	ret

insert:
; [Refs: qring, act7, actv, format, format2]
	call	insert0
	mov	cl, action
	xor	[edi*4], cl
	jmp	accept

format:
; ( ?? -- ) ??
; [Refs: e]
	test	action, 12o ; ignore 3 and 9
	jz	@f
	drop
	ret
@@:	mov	edx, eax
	and	edx, 0fc000000h
	jz	@f
	cmp	edx, 0fc000000h
	jnz	format2
@@:	shl	eax, 5
	xor	al, 2 ; 6
	cmp	action, 4
	jz	@f
	xor	al, 13o ; 8
@@:	cmp	base, 10
	jz	@f
	xor	al, 20o
@@:	mov	words, 1
	jmp	insert

format2:
; [Refs: format]
	dup_
	mov	eax, 1 ; 5
	cmp	action, 4
	jz	@f
	mov	al, 3 ; 2
@@:	cmp	base, 10
	jz	@f
	xor	al, 20o
@@:	xchg	eax, [esi]
	mov	words, 2
	jmp	insert

del:
; [Refs: ekeys]
	call	enstack
	mov	edi, pcad
	mov	ecx, lcad
	sub	ecx, edi
	shl	edi, 2
	push	esi
	mov	esi, cad
	shl	esi, 2
	rep	movsd
	pop	esi
	jmp	mcur

enstack:
; [Refs: del]
	dup_
	mov	eax, cad
	sub	eax, pcad
	jz	ens
	mov	ecx, eax
	xchg	eax, edx
	push	esi
	mov	esi, cad
	lea	esi, [esi*4-4]
	mov	edi, trash
@@:	std
	lodsd
	cld
	stosd
	next	@b
	xchg	eax, edx
	stosd
	mov	trash, edi
	pop	esi

ens:
; [Refs: enstack]
	drop
	ret

pad:
; [Refs: forth2]
	pop	edx        	  ; Move return address into vector.
	mov	vector, edx
	add	edx, 28*5	  ; 
	mov	board, edx
	sub	edx, 4*4
	mov	shift, edx
@@:	call	key                ; (task switch)
	mov	edx, vector
	add	edx, eax           ; ?? add CF key code to vector ??
	lea	edx, [5+eax*4+edx] ;
	add	edx, [-4+edx]
	drop
	call	edx
	jmp	@b

org (1200h-1)*4
	dd 0
end start



